{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Haskell language support powered by the Haskell Language Server",
  "properties": {
    "haskell.cabalFormattingProvider": {
      "default": "cabal-gild",
      "description": "The formatter to use when formatting a document or range of a cabal formatter. Ensure the plugin is enabled.",
      "enum": [
        "cabal-gild",
        "cabal-fmt",
        "none"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.checkProject": {
      "default": true,
      "description": "Whether to typecheck the entire project on load. It could drive to bad performance in large projects.",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.formattingProvider": {
      "default": "ormolu",
      "description": "The formatter to use when formatting a document or range. Ensure the plugin is enabled.",
      "enum": [
        "brittany",
        "floskell",
        "fourmolu",
        "ormolu",
        "stylish-haskell",
        "none"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.ghcupExecutablePath": {
      "default": "",
      "markdownDescription": "Manually set a ghcup executable path.",
      "scope": "resource",
      "type": "string"
    },
    "haskell.logFile": {
      "default": "",
      "description": "If set, redirects the logs to a file.",
      "scope": "resource",
      "type": "string"
    },
    "haskell.manageHLS": {
      "default": "PATH",
      "description": "How to manage/find HLS installations.",
      "enum": [
        "GHCup",
        "PATH"
      ],
      "enumDescriptions": [
        "Will use ghcup and manage Haskell toolchain in the default location (usually '~/.ghcup')",
        "Discovers HLS and other executables in system PATH"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.maxCompletions": {
      "default": 40,
      "description": "Maximum number of completions sent to the editor.",
      "scope": "resource",
      "type": "integer"
    },
    "haskell.metadataURL": {
      "default": "",
      "description": "An optional URL to override where ghcup checks for tool download info (usually at: https://raw.githubusercontent.com/haskell/ghcup-metadata/master/ghcup-0.0.7.yaml)",
      "scope": "resource",
      "type": "string"
    },
    "haskell.openDocumentationInHackage": {
      "default": true,
      "description": "When opening 'Documentation' for external libraries, open in hackage by default. Set to false to instead open in vscode.",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.openSourceInHackage": {
      "default": true,
      "description": "When opening 'Source' for external libraries, open in hackage by default. Set to false to instead open in vscode.",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.alternateNumberFormat.globalOn": {
      "default": true,
      "description": "Enables alternateNumberFormat plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.cabal-fmt.config.path": {
      "default": "cabal-fmt",
      "markdownDescription": "Set path to 'cabal-fmt' executable",
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.cabal-gild.config.path": {
      "default": "cabal-gild",
      "markdownDescription": "Set path to 'cabal-gild' executable",
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.cabal.codeActionsOn": {
      "default": true,
      "description": "Enables cabal code actions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.cabal.completionOn": {
      "default": true,
      "description": "Enables cabal completions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.cabal.diagnosticsOn": {
      "default": true,
      "description": "Enables cabal diagnostics",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.callHierarchy.globalOn": {
      "default": true,
      "description": "Enables callHierarchy plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.changeTypeSignature.globalOn": {
      "default": true,
      "description": "Enables changeTypeSignature plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.class.codeActionsOn": {
      "default": true,
      "description": "Enables class code actions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.class.codeLensOn": {
      "default": true,
      "description": "Enables class code lenses",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.eval.config.diff": {
      "default": true,
      "markdownDescription": "Enable the diff output (WAS/NOW) of eval lenses",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.eval.config.exception": {
      "default": false,
      "markdownDescription": "Enable marking exceptions with `*** Exception:` similarly to doctest and GHCi.",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.eval.globalOn": {
      "default": true,
      "description": "Enables eval plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.explicit-fields.globalOn": {
      "default": true,
      "description": "Enables explicit-fields plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.explicit-fixity.globalOn": {
      "default": true,
      "description": "Enables explicit-fixity plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.fourmolu.config.external": {
      "default": false,
      "markdownDescription": "Call out to an external \"fourmolu\" executable, rather than using the bundled library.",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.fourmolu.config.path": {
      "default": "fourmolu",
      "markdownDescription": "Set path to executable (for \"external\" mode).",
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.gadt.globalOn": {
      "default": true,
      "description": "Enables gadt plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-code-actions-bindings.globalOn": {
      "default": true,
      "description": "Enables ghcide-code-actions-bindings plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-code-actions-fill-holes.globalOn": {
      "default": true,
      "description": "Enables ghcide-code-actions-fill-holes plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-code-actions-imports-exports.globalOn": {
      "default": true,
      "description": "Enables ghcide-code-actions-imports-exports plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-code-actions-type-signatures.globalOn": {
      "default": true,
      "description": "Enables ghcide-code-actions-type-signatures plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-completions.config.autoExtendOn": {
      "default": true,
      "markdownDescription": "Extends the import list automatically when completing a out-of-scope identifier",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-completions.config.snippetsOn": {
      "default": true,
      "markdownDescription": "Inserts snippets when using code completions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-completions.globalOn": {
      "default": true,
      "description": "Enables ghcide-completions plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-hover-and-symbols.hoverOn": {
      "default": true,
      "description": "Enables ghcide-hover-and-symbols hover",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-hover-and-symbols.symbolsOn": {
      "default": true,
      "description": "Enables ghcide-hover-and-symbols symbols",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ghcide-type-lenses.config.mode": {
      "default": "always",
      "description": "Control how type lenses are shown",
      "enum": [
        "always",
        "exported",
        "diagnostics"
      ],
      "enumDescriptions": [
        "Always displays type lenses of global bindings",
        "Only display type lenses of exported global bindings",
        "Follows error messages produced by GHC about missing signatures"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.ghcide-type-lenses.globalOn": {
      "default": true,
      "description": "Enables ghcide-type-lenses plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.hlint.codeActionsOn": {
      "default": true,
      "description": "Enables hlint code actions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.hlint.config.flags": {
      "default": [],
      "markdownDescription": "Flags used by hlint",
      "scope": "resource",
      "type": "array"
    },
    "haskell.plugin.hlint.diagnosticsOn": {
      "default": true,
      "description": "Enables hlint diagnostics",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.importLens.codeActionsOn": {
      "default": true,
      "description": "Enables importLens code actions",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.importLens.codeLensOn": {
      "default": true,
      "description": "Enables importLens code lenses",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.moduleName.globalOn": {
      "default": true,
      "description": "Enables moduleName plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.ormolu.config.external": {
      "default": false,
      "markdownDescription": "Call out to an external \"ormolu\" executable, rather than using the bundled library",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.overloaded-record-dot.globalOn": {
      "default": true,
      "description": "Enables overloaded-record-dot plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.pragmas-completion.globalOn": {
      "default": true,
      "description": "Enables pragmas-completion plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.pragmas-disable.globalOn": {
      "default": true,
      "description": "Enables pragmas-disable plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.pragmas-suggest.globalOn": {
      "default": true,
      "description": "Enables pragmas-suggest plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.qualifyImportedNames.globalOn": {
      "default": true,
      "description": "Enables qualifyImportedNames plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.rename.config.crossModule": {
      "default": false,
      "markdownDescription": "Enable experimental cross-module renaming",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.rename.globalOn": {
      "default": true,
      "description": "Enables rename plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.retrie.globalOn": {
      "default": true,
      "description": "Enables retrie plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.semanticTokens.config.classMethodToken": {
      "default": "method",
      "description": "LSP semantic token type to use for typeclass methods",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.classToken": {
      "default": "class",
      "description": "LSP semantic token type to use for typeclasses",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.dataConstructorToken": {
      "default": "enumMember",
      "description": "LSP semantic token type to use for data constructors",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.functionToken": {
      "default": "function",
      "description": "LSP semantic token type to use for functions",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.moduleToken": {
      "default": "namespace",
      "description": "LSP semantic token type to use for modules",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.operatorToken": {
      "default": "operator",
      "description": "LSP semantic token type to use for operators",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.patternSynonymToken": {
      "default": "macro",
      "description": "LSP semantic token type to use for pattern synonyms",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.recordFieldToken": {
      "default": "property",
      "description": "LSP semantic token type to use for record fields",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.typeConstructorToken": {
      "default": "enum",
      "description": "LSP semantic token type to use for type constructors",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.typeFamilyToken": {
      "default": "interface",
      "description": "LSP semantic token type to use for type families",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.typeSynonymToken": {
      "default": "type",
      "description": "LSP semantic token type to use for type synonyms",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.typeVariableToken": {
      "default": "typeParameter",
      "description": "LSP semantic token type to use for type variables",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.config.variableToken": {
      "default": "variable",
      "description": "LSP semantic token type to use for variables",
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "enumDescriptions": [
        "LSP Semantic Token Type: namespace",
        "LSP Semantic Token Type: type",
        "LSP Semantic Token Type: class",
        "LSP Semantic Token Type: enum",
        "LSP Semantic Token Type: interface",
        "LSP Semantic Token Type: struct",
        "LSP Semantic Token Type: typeParameter",
        "LSP Semantic Token Type: parameter",
        "LSP Semantic Token Type: variable",
        "LSP Semantic Token Type: property",
        "LSP Semantic Token Type: enumMember",
        "LSP Semantic Token Type: event",
        "LSP Semantic Token Type: function",
        "LSP Semantic Token Type: method",
        "LSP Semantic Token Type: macro",
        "LSP Semantic Token Type: keyword",
        "LSP Semantic Token Type: modifier",
        "LSP Semantic Token Type: comment",
        "LSP Semantic Token Type: string",
        "LSP Semantic Token Type: number",
        "LSP Semantic Token Type: regexp",
        "LSP Semantic Token Type: operator",
        "LSP Semantic Token Type: decorator"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.plugin.semanticTokens.globalOn": {
      "default": false,
      "description": "Enables semanticTokens plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.splice.globalOn": {
      "default": true,
      "description": "Enables splice plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.plugin.stan.globalOn": {
      "default": false,
      "description": "Enables stan plugin",
      "scope": "resource",
      "type": "boolean"
    },
    "haskell.promptBeforeDownloads": {
      "default": "true",
      "markdownDescription": "Prompt before performing any downloads.",
      "scope": "machine",
      "type": "boolean"
    },
    "haskell.releasesDownloadStoragePath": {
      "default": "",
      "markdownDescription": "An optional path where downloaded metadata will be stored. Check the default value [here](https://github.com/haskell/vscode-haskell#downloaded-binaries)",
      "scope": "resource",
      "type": "string"
    },
    "haskell.releasesURL": {
      "default": "",
      "description": "An optional URL to override where ghcup checks for HLS-GHC compatibility list (usually at: https://raw.githubusercontent.com/haskell/ghcup-metadata/master/hls-metadata-0.0.1.json)",
      "scope": "resource",
      "type": "string"
    },
    "haskell.serverEnvironment": {
      "default": {},
      "markdownDescription": "Define environment variables for the language server.",
      "scope": "resource",
      "type": "object"
    },
    "haskell.serverExecutablePath": {
      "default": "",
      "markdownDescription": "Manually set a language server executable. Can be something on the $PATH or the full path to the executable itself. Works with `~,` `${HOME}` and `${workspaceFolder}`.",
      "scope": "machine-overridable",
      "type": "string"
    },
    "haskell.serverExtraArgs": {
      "default": "",
      "markdownDescription": "Pass additional arguments to the language server.",
      "scope": "resource",
      "type": "string"
    },
    "haskell.sessionLoading": {
      "default": "singleComponent",
      "description": "Preferred approach for loading package components. Setting this to 'multiple components' (EXPERIMENTAL) allows the build tool (such as `cabal` or `stack`) to [load multiple components at once](https://github.com/haskell/cabal/pull/8726), which is a significant improvement.",
      "enum": [
        "singleComponent",
        "multipleComponents"
      ],
      "enumDescriptions": [
        "Always load only a single component at a time. This is the most reliable option if you encountered any issues with the other options.",
        "Prefer a multiple component session, if the build tool supports it. At the moment, only `cabal` supports multiple components session loading. If the `cabal` version does not support loading multiple components at once, we gracefully fall back to \"singleComponent\" mode."
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.toolchain": {
      "default": {},
      "description": "When manageHLS is set to GHCup, this can overwrite the automatic toolchain configuration with a more specific one. When a tool is omitted, the extension will manage the version (for 'ghc' we try to figure out the version the project requires). The format is '{\"tool\": \"version\", ...}'. 'version' accepts all identifiers that 'ghcup' accepts.",
      "scope": "resource",
      "type": "object"
    },
    "haskell.trace.client": {
      "default": "info",
      "description": "Sets the log level in the client side.",
      "enum": [
        "off",
        "error",
        "info",
        "debug"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.trace.server": {
      "default": "off",
      "description": "Traces the communication between VS Code and the language server.",
      "enum": [
        "off",
        "messages",
        "verbose"
      ],
      "scope": "resource",
      "type": "string"
    },
    "haskell.upgradeGHCup": {
      "default": true,
      "description": "Whether to upgrade GHCup automatically when 'manageHLS' is set to 'GHCup'.",
      "scope": "resource",
      "type": "boolean"
    }
  }
}
